{\rtf1\ansi\ansicpg936\cocoartf2509
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset134 PingFangSC-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red251\green0\blue7;\red255\green255\blue11;
\red36\green255\blue255;\red0\green0\blue0;\red57\green192\blue38;\red56\green185\blue199;\red209\green113\blue37;
\red219\green39\blue218;\red170\green171\blue37;\red19\green150\blue163;}
{\*\expandedcolortbl;;\csgray\c0;\cssrgb\c100000\c12195\c0;\cssrgb\c100000\c100000\c0;
\cssrgb\c4983\c100000\c100000;\cssrgb\c0\c1\c1;\cssrgb\c25704\c77963\c19556;\cssrgb\c25544\c77008\c82022;\cssrgb\c85991\c52029\c18734;
\cssrgb\c89513\c29738\c88483;\cssrgb\c72330\c71683\c18597;\cssrgb\c0\c65000\c70000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww18700\viewh11920\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0  
\f1\fs26 \cf2 \CocoaLigature0 0000000000400f20 <phase_1>:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
  400f20:       48 83 ec 08             sub    $0x8,%rsp\
  400f24:       be f0 24 40 00          mov    $0x4024f0,%esi\
  400f29:       e8 c8 03 00 00          callq  4012f6 <strings_not_equal>\
  400f2e:       85 c0                   test   %eax,%eax\
  400f30:       74 05                   je     400f37 <phase_1+0x17>\
  400f32:       e8 5c 06 00 00          callq  401593 <explode_bomb>\
  400f37:       48 83 c4 08             add    $0x8,%rsp\
  400f3b:       c3                      retq\
\
I am not part of the problem. I am a Republican.\
\
0000000000400f3c <phase_2>:\
  400f3c:       53                      push   %rbx\
  400f3d:       48 83 ec 20             sub    $0x20,%rsp\
  400f41:       48 89 e6                mov    %rsp,%rsi\
  400f44:       e8 80 06 00 00          callq  4015c9 <read_six_numbers>\
  \cf3 400f49:       83 3c 24 01             cmpl   $0x1,(%rsp)           \
  400f4d:       74 05                   je     400f54 <phase_2+0x18>\cf2 \
  400f4f:       e8 3f 06 00 00          callq  401593 <explode_bomb>\
  \cf3 400f54:       bb 01 00 00 00          mov    $0x1,%ebx                  ebx=1\
  400f59:       eb 1a                   jmp    400f75 <phase_2+0x39>\cf2 \
  \cf4 400f5b:       48 63 d3                movslq %ebx,%rdx                  rdx=ebx\
  400f5e:       8d 43 ff                lea    -0x1(%rbx),%eax            eax=rbx-1\
  400f61:       48 98                   cltq\
  400f63:       8b 04 84                mov    (%rsp,%rax,4),%eax\
  400f66:       01 c0                   add    %eax,%eax\
  400f68:       39 04 94                cmp    %eax,(%rsp,%rdx,4)\
  400f6b:       74 05                   je     400f72 <phase_2+0x36>\
\cf2   400f6d:       e8 21 06 00 00          callq  401593 <explode_bomb>\
  400f72:       83 c3 01                add    $0x1,%ebx\
  \cf3 400f75:       83 fb 05                cmp    $0x5,%ebx                   if ebx<=5\
  400f78:       7e e1                   jle    400f5b <phase_2+0x1f>\
\cf2   400f7a:       48 83 c4 20             add    $0x20,%rsp\
  400f7e:       5b                      pop    %rbx\
  400f7f:       c3                      retq\
\
\
1 2 4 8 16 32\
\
\
0000000000400f80 <phase_3>:\
  400f80:       48 83 ec 18             sub    $0x18,%rsp\
  400f84:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\
  400f89:       48 8d 54 24 0c          lea    0xc(%rsp),%rdx\
  400f8e:       be 65 28 40 00          mov    $0x402865,%esi\
  400f93:       b8 00 00 00 00          mov    $0x0,%eax\
  400f98:       e8 a3 fc ff ff          callq  400c40 <__isoc99_sscanf@plt>\
 \cf3  400f9d:       83 f8 01                cmp    $0x1,%eax\
  400fa0:       7f 05                   jg     400fa7 <phase_3+0x27>\
\cf2   400fa2:       e8 ec 05 00 00          callq  401593 <explode_bomb>\
  400fa7:       83 7c 24 0c 07          \cf3 cmpl   $0x7,0xc(%rsp)\
  400fac:       77 3c                   ja     400fea <phase_3+0x6a>\
  400fae:       8b 44 24 0c             mov    0xc(%rsp),%eax\
\cf2   \cf4 400fb2:       ff 24 c5 60 25 40 00    jmpq   *0x402560(,%rax,8)    \cf5 400fc7\cf2 \
  400fb9:       b8 c8 02 00 00          mov    $0x2c8,%eax\
  400fbe:       eb 3b                   jmp    400ffb <phase_3+0x7b>\
  400fc0:       b8 71 02 00 00          mov    $0x271,%eax\
  400fc5:       eb 34                   jmp    400ffb <phase_3+0x7b>\
  \cf4 400fc7:       b8 8d 01 00 00          mov    $0x18d,%eax\
\cf2   400fcc:       eb 2d                   jmp    400ffb <phase_3+0x7b>\
  400fce:       b8 66 02 00 00          mov    $0x266,%eax\
  400fd3:       eb 26                   jmp    400ffb <phase_3+0x7b>\
  400fd5:       b8 06 03 00 00          mov    $0x306,%eax\
  400fda:       eb 1f                   jmp    400ffb <phase_3+0x7b>\
  400fdc:       b8 3a 02 00 00          mov    $0x23a,%eax\
  400fe1:       eb 18                   jmp    400ffb <phase_3+0x7b>\
  400fe3:       b8 e9 01 00 00          mov    $0x1e9,%eax\
  400fe8:       eb 11                   jmp    400ffb <phase_3+0x7b>\
  400fea:       e8 a4 05 00 00          callq  401593 <explode_bomb>\
  400fef:       b8 00 00 00 00          mov    $0x0,%eax\
  400ff4:       eb 05                   jmp    400ffb <phase_3+0x7b>\
  400ff6:       b8 05 01 00 00          mov    $0x105,%eax\
  400ffb:       3b 44 24 08             cmp    0x8(%rsp),%eax\
  400fff:       74 05                   je     401006 <phase_3+0x86>\
  401001:       e8 8d 05 00 00          callq  401593 <explode_bomb>\
  401006:       48 83 c4 18             add    $0x18,%rsp\
  40100a:       c3                      retq\
\
3 397\
\
\
0000000000401040 <phase_4>:\
  401040:       48 83 ec 18             sub    $0x18,%rsp\
  401044:       48 8d 4c 24 08          lea    0x8(%rsp),%rcx\
  401049:       48 8d 54 24 0c          lea    0xc(%rsp),%rdx\
  40104e:       be 65 28 40 00          mov    $0x402865,%esi\
  401053:       b8 00 00 00 00          mov    $0x0,%eax\
  401058:       e8 e3 fb ff ff          callq  400c40 <__isoc99_sscanf@plt>\
  40105d:       83 f8 02                cmp    $0x2,%eax\
  401060:       75 0d                   jne    \cf3 40106f \cf2 <phase_4+0x2f>\
  401062:       8b 44 24 0c             mov    0xc(%rsp),%eax\
  401066:       85 c0                   test   %eax,%eax\
  401068:       78 05                   js     \cf3 40106f\cf2  <phase_4+0x2f>         
\f2 \'c8\'e7\'b9\'fb<0 
\f1 bomb\
  40106a:       83 f8 0e                \cf3 cmp    $0xe,%eax                     \cf6 eax <= 14\cf3 \
  40106d:       7e 05                   jle    401074 <phase_4+0x34>\
  40106f:       e8 1f 05 00 00          callq  401593 <explode_bomb>\cf2 \
  401074:       ba 0e 00 00 00          mov    $0xe,%edx                     edx = 14\
  401079:       be 00 00 00 00          mov    $0x0,%esi                     esi = 0\
  40107e:       8b 7c 24 0c             mov    0xc(%rsp),%edi                edi = 
\f2 \'ca\'e4\'c8\'eb\'b5\'c4\'b5\'da\'d2\'bb\'b8\'f6\'ca\'fd
\f1 \
  401082:       e8 84 ff ff ff          callq  40100b <func4>\
  401087:       83 f8 2b                cmp    $0x2b,%eax\
  40108a:       75 07                   jne    \cf3 401093 \cf2 <phase_4+0x53>\
  40108c:       83 7c 24 08 2b          cmpl   $0x2b,0x8(%rsp)\
  401091:       74 05                   je     401098 <phase_4+0x58>\
  \cf3 401093:       e8 fb 04 00 00          callq  401593 <explode_bomb>\cf2 \
  401098:       48 83 c4 18             add    $0x18,%rsp\
  40109c:       c3                      retq\
\
\
12 43\
\
\
000000000040109d <phase_5>:\
  40109d:       53                      push   %rbx\
  40109e:       48 83 ec 10             sub    $0x10,%rsp\
  4010a2:       48 89 fb                mov    %rdi,%rbx\
  4010a5:       e8 37 02 00 00          callq  4012e1 <string_length>\
  4010aa:       83 f8 06                cmp    $0x6,%eax\
  4010ad:       74 05                   je     4010b4 <phase_5+0x17>\
  4010af:       e8 df 04 00 00          callq  401593 <explode_bomb>\
  4010b4:       b8 00 00 00 00          mov    $0x0,%eax\
  4010b9:       eb 17                   jmp    4010d2 <phase_5+0x35>\
  4010bb:       48 63 d0                movslq %eax,%rdx\
  4010be:       0f b6 0c 13             movzbl (%rbx,%rdx,1),%ecx\
  4010c2:       83 e1 0f                and    $0xf,%ecx\
  4010c5:       0f b6 89 a0 25 40 00    movzbl 0x4025a0(%rcx),%ecx\
  4010cc:       88 0c 14                mov    %cl,(%rsp,%rdx,1)\
  4010cf:       83 c0 01                add    $0x1,%eax\
  4010d2:       83 f8 05                cmp    $0x5,%eax\
  4010d5:       7e e4                   jle    4010bb <phase_5+0x1e>\
  4010d7:       c6 44 24 06 00          movb   $0x0,0x6(%rsp)\
  4010dc:       be 4e 25 40 00          mov    $0x40254e,%esi\
  4010e1:       48 89 e7                mov    %rsp,%rdi\
  4010e4:       e8 0d 02 00 00          callq  4012f6 <strings_not_equal>\
  4010e9:       85 c0                   test   %eax,%eax\
  4010eb:       74 05                   je     4010f2 <phase_5+0x55>\
  4010ed:       e8 a1 04 00 00          callq  401593 <explode_bomb>\
  4010f2:       48 83 c4 10             add    $0x10,%rsp\
  4010f6:       5b                      pop    %rbx\
  4010f7:       c3                      retq\
\
\
\
\
\
\
Hw 7:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf7 void\cf2  testCount() \{\
  \cf8 // dict1\cf2 \
  \cf7 const\cf2  \cf7 char\cf2  *keys1[] = \{\cf9 "a"\cf2 , \cf9 "b"\cf2 , \cf9 "c"\cf2 , \cf9 "e"\cf2 , \cf9 "f"\cf2 \};\
  \cf7 int\cf2  values1[] = \{\cf9 1\cf2 , \cf9 2\cf2 , \cf9 3\cf2 , \cf9 4\cf2 , \cf9 5\cf2 \};\
  dictNode *dict = \cf9 NULL\cf2 ;\
  assert(countKeys(dict) == \cf9 0\cf2 );\
  dict = makeDict(keys1, values1, \cf9 5\cf2 );\
  assert(countKeys(dict) == \cf9 5\cf2 );\
  destroyDict(&dict);\
  printf(\cf9 "passed testCount\cf10 \\n\cf9 "\cf2 );\
\}\
\
\
\cf7 void\cf2  testLookup() \{\
  \cf8 // dict1\cf2 \
  \cf7 const\cf2  \cf7 char\cf2  *keys1[] = \{\cf9 "a"\cf2 , \cf9 "b"\cf2 , \cf9 "c"\cf2 , \cf9 "e"\cf2 , \cf9 "f"\cf2 \};\
  \cf7 int\cf2  values1[] = \{\cf9 1\cf2 , \cf9 2\cf2 , \cf9 3\cf2 , \cf9 4\cf2 , \cf9 5\cf2 \};\
  \cf8 // dict2: an out of order dict to test for proper\cf2 \
  \cf8 // early termination of search.\cf2 \
  \cf7 const\cf2  \cf7 char\cf2  *keys2[] = \{\cf9 "happy"\cf2 , \cf9 "angry"\cf2 \};\
  \cf7 int\cf2  values2[] = \{\cf9 10\cf2 , \cf9 20\cf2 \};\
  \cf8 // testing lookup in empty dict\cf2 \
  dictNode *dict = \cf9 NULL\cf2 ;\
  assert(lookupKey(dict, \cf9 "a"\cf2 ) == -\cf9 1\cf2 );\
  \cf8 // testing lookup in dict1\cf2 \
  dict = makeDict(keys1, values1, \cf9 5\cf2 );\
  assert(lookupKey(dict, \cf9 "a"\cf2 ) == \cf9 1\cf2 );\
  assert(lookupKey(dict, \cf9 "b"\cf2 ) == \cf9 2\cf2 );\
  assert(lookupKey(dict, \cf9 "f"\cf2 ) == \cf9 5\cf2 );\
  assert(lookupKey(dict, \cf9 "d"\cf2 ) == -\cf9 1\cf2 );\
  assert(lookupKey(dict, \cf9 "c"\cf2 ) == \cf9 3\cf2 );\
  assert(lookupKey(dict, \cf9 "e"\cf2 ) == \cf9 4\cf2 );\
\
\
\
  destroyDict(&dict);\
\
\cf8 // testing lookup in dict2\cf2 \
  dict = makeDict(keys2, values2, \cf9 2\cf2 );\
  assert(lookupKey(dict, \cf9 "happy"\cf2 ) == \cf9 10\cf2 );\
  \cf8 // angry key is stored out of order, your\cf2 \
  \cf8 // search should have ended when it sees\cf2 \
  \cf8 // that happy>angry instead of searching \cf2 \
  \cf8 // till the end.\cf2 \
  assert(lookupKey(dict, \cf9 "angry"\cf2 ) == -\cf9 1\cf2 );\
  assert(lookupKey(dict, \cf9 "other"\cf2 ) == -\cf9 1\cf2 );\
  destroyDict(&dict);\
  printf(\cf9 "passed testLookup\cf10 \\n\cf9 "\cf2 );\
\} \
\
\
\cf7 void\cf2  testDelete() \{\
  dictNode *dict = \cf9 NULL\cf2 ;\
  \cf8 // checking delete from empty dict\cf2 \
  deleteKey(&dict, \cf9 "abc"\cf2 );\
  assert(dict == \cf9 NULL\cf2 );\
  \cf8 // dict1\cf2 \
  \cf7 const\cf2  \cf7 char\cf2  *keys1[] = \{\cf9 "a"\cf2 , \cf9 "b"\cf2 , \cf9 "c"\cf2 , \cf9 "e"\cf2 , \cf9 "f"\cf2 \};\
  \cf7 int\cf2  values1[] = \{\cf9 1\cf2 , \cf9 2\cf2 , \cf9 3\cf2 , \cf9 4\cf2 , \cf9 5\cf2 \};\
  dict = makeDict(keys1, values1, \cf9 5\cf2 );\
  \cf8 // checking delete from the head\cf2 \
  deleteKey(&dict, \cf9 "a"\cf2 );\
  assertEqualDict(dict, keys1+\cf9 1\cf2 , values1+\cf9 1\cf2 , \cf9 4\cf2 );\
  \cf8 // checking delete from the tail\cf2 \
  deleteKey(&dict, \cf9 "f"\cf2 );\
  assertEqualDict(dict, keys1+\cf9 1\cf2 , values1+\cf9 1\cf2 , \cf9 3\cf2 );\
\
  \cf8 // checking delete from the middle\cf2 \
  \cf7 const\cf2  \cf7 char\cf2  *keys2[] = \{\cf9 "b"\cf2 , \cf9 "e"\cf2 \};\
  \cf7 int\cf2  values2[] = \{\cf9 2\cf2 ,\cf9 4\cf2 \};\
  deleteKey(&dict, \cf9 "c"\cf2 );\
  assertEqualDict(dict, keys2, values2, \cf9 2\cf2 );\
  destroyDict(&dict);\
\
  \cf8 // checking that delete stops after search key is smaller than current key\cf2 \
  \cf7 const\cf2  \cf7 char\cf2  *keys3[] = \{\cf9 "a"\cf2 ,\cf9 "c"\cf2 , \cf9 "b"\cf2 , \cf9 "f"\cf2 \};\
  \cf7 int\cf2  values3[] = \{\cf9 1\cf2 , \cf9 2\cf2 , \cf9 3\cf2 , \cf9 5\cf2 \};\
  dict = makeDict(keys3, values3, \cf9 4\cf2 );\
  deleteKey(&dict, \cf9 "b"\cf2 );\
  assertEqualDict(dict, keys3, values3, \cf9 4\cf2 );\
  destroyDict(&dict);\
  printf(\cf9 "passed testDelete\cf10 \\n\cf9 "\cf2 );\
\}\
\
\
\
Shell lab:\
Reference output:\
#\
# trace14.txt - Simple error handling\
#\
tsh> ./bogus\
./bogus: Command not found\
tsh> ./myspin 4 &\
[1] (31436) ./myspin 4 &\
tsh> fg\
fg command requires PID or %jobid argument\
tsh> bg\
bg command requires PID or %jobid argument\
tsh> fg a\
fg: argument must be a PID or %jobid\
tsh> bg a\
bg: argument must be a PID or %jobid\
tsh> fg 9999999\
(9999999): No such process\
tsh> bg 9999999\
(9999999): No such process\
tsh> fg %2\
%2: No such job\
tsh> fg %1\
Job [1] (31436) stopped by signal 20\
tsh> bg %2\
%2: No such job\
tsh> bg %1\
[1] (31436) ./myspin 4 &\
tsh> jobs\
[1] (31436) Running ./myspin 4 &\
Student's output:\
#\
# trace14.txt - Simple error handling\
#\
tsh> ./bogus\
./bogus: Command not found\
tsh> ./myspin 4 &\
[1] (31485) ./myspin 4 &\
tsh> fg\
fg command requires PID or %jobid argument\
tsh> bg\
bg command requires PID or %jobid argument\
tsh> fg a\
fg: argument must be a pid or %jobid\
tsh> bg a\
bg: argument must be a pid or %jobid\
tsh> fg 9999999\
(9999999): No such process\
tsh> bg 9999999\
(9999999): No such process\
tsh> fg %2\
%2: No such job\
tsh> fg %1\
Job [1] (31485) stopped by signal 20\
tsh> bg %2\
%2: No such job\
tsh> bg %1\
[1] (31485) ./myspin 4 &\
tsh> jobs\
[1] (31485) Running ./myspin 4 &\
\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 //  File           : cart_driver.c\cf2 \
\cf8 //  Description    : This is the implementation of the standardized IO functions\cf2 \
\cf8 //                   for used to access the CART storage system.\cf2 \
\cf8 //\cf2 \
\cf8 //  Author         : [**YOUR NAME**]\cf2 \
\cf8 //  PSU email      : [**YOUR Email**]\cf2 \
\cf8 //\cf2 \
\
\cf8 // Includes\cf2 \
\cf10 #include \cf9 <stdlib.h>\cf2 \
\
\cf8 // Project Includes\cf2 \
\cf10 #include \cf9 "cart_driver.h"\cf2 \
\cf10 #include \cf9 "cart_controller.h"\cf2 \
\
\cf8 //\cf2 \
\cf8 // Implementation\cf2 \
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_poweron\cf2 \
\cf8 // Description  : Startup up the CART interface, initialize filesystem\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : none\cf2 \
\cf8 // Outputs      : 0 if successful, -1 if failure\cf2 \
\
\cf7 int32_t\cf2  cart_poweron(\cf7 void\cf2 ) \{\
\
  \cf8 // Return successfully\cf2 \
  \cf11 return\cf2 (\cf9 0\cf2 );\
\}\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_poweroff\cf2 \
\cf8 // Description  : Shut down the CART interface, close all files\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : none\cf2 \
\cf8 // Outputs      : 0 if successful, -1 if failure\cf2 \
\
\cf7 int32_t\cf2  cart_poweroff(\cf7 void\cf2 ) \{\
\
  \cf8 // Return successfully\cf2 \
  \cf11 return\cf2 (\cf9 0\cf2 );\
\}\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_open\cf2 \
\cf8 // Description  : This function opens the file and returns a file handle\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : path - filename of the file to open\cf2 \
\cf8 // Outputs      : file handle if successful, -1 if failure\cf2 \
\
\cf7 int16_t\cf2  cart_open(\cf7 char\cf2  *path) \{\
\
  \cf8 // THIS SHOULD RETURN A FILE HANDLE\cf2 \
  \cf11 return\cf2  (\cf9 0\cf2 );\
\}\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_close\cf2 \
\cf8 // Description  : This function closes the file\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : fd - the file descriptor\cf2 \
\cf8 // Outputs      : 0 if successful, -1 if failure\cf2 \
\
\cf7 int16_t\cf2  cart_close(\cf7 int16_t\cf2  fd) \{\
\
  \cf8 // Return successfully\cf2 \
  \cf11 return\cf2  (\cf9 0\cf2 );\
\}\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_read\cf2 \
\cf8 // Description  : Reads "count" bytes from the file handle "fh" into the \cf2 \
\cf8 //                buffer "buf"\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : fd - filename of the file to read from\cf2 \
\cf8 //                buf - pointer to buffer to read into\cf2 \
\cf8 //                count - number of bytes to read\cf2 \
\cf8 // Outputs      : bytes read if successful, -1 if failure\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf7 int32_t\cf2  cart_read(\cf7 int16_t\cf2  fd, \cf7 void\cf2  *buf, \cf7 int32_t\cf2  count) \{\
\
  \cf8 // Return successfully\cf2 \
  \cf11 return\cf2  (count);\
\}\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_write\cf2 \
\cf8 // Description  : Writes "count" bytes to the file handle "fh" from the \cf2 \
\cf8 //                buffer  "buf"\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : fd - filename of the file to write to\cf2 \
\cf8 //                buf - pointer to buffer to write from\cf2 \
\cf8 //                count - number of bytes to write\cf2 \
\cf8 // Outputs      : bytes written if successful, -1 if failure\cf2 \
\
\cf7 int32_t\cf2  cart_write(\cf7 int16_t\cf2  fd, \cf7 void\cf2  *buf, \cf7 int32_t\cf2  count) \{\
\
  \cf8 // Return successfully\cf2 \
  \cf11 return\cf2  (count);\
\}\
\
\cf8 ////////////////////////////////////////////////////////////////////////////////\cf2 \
\cf8 //\cf2 \
\cf8 // Function     : cart_read\cf2 \
\cf8 // Description  : Seek to specific point in the file\cf2 \
\cf8 //\cf2 \
\cf8 // Inputs       : fd - filename of the file to write to\cf2 \
\cf8 //                loc - offfset of file in relation to beginning of file\cf2 \
\cf8 // Outputs      : 0 if successful, -1 if failure\cf2 \
\
\cf7 int32_t\cf2  cart_seek(\cf7 int16_t\cf2  fd, \cf7 uint32_t\cf2  loc) \cb12 \{\cb1 \
\
  \cf8 // Return successfully\cf2 \
  \cf11 return\cf2  (\cf9 0\cf2 );\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cb12 \}\cb1 \
}